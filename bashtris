#!/bin/bash
#
# Author: Tobias Schrader
set -o nounset

source engine.sh

debug=false
prg=$(basename "$0")

while getopts ':d' optname; do
  case $optname in
    d) debug=true;;
    :) echo "$prg: Argument for option $OPTARG is missing" >&2; exit 2;;
    \?) echo "$prg: Unknown option $OPTARG" >&2; exit 2;;
    *) echo "$prg: Internal error, unexpected option $OPTNAME" >&2; exit 3;;
  esac
done
shift $(( $OPTIND - 1 ))

# graphic representations
declare -A rep
rep[empty]=' '
rep[border]='#'
rep[falling]='@'
rep[base]='O'

declare -i tickrate=500000

declare -i score=0
declare -i lnum=0

declare -i dim=3 #size of piece

#field
declare -i width=8
declare -i height=12

declare -i xsize=$width+2
declare -i ysize=$height+3

declare -a field

getfield() {
  local x=$1
  local y=$2
  echo "${field[$x + $width * $y]}"
}

setfield() {
  local x=$1
  local y=$2
  local val=$3
  field[$x + $width * $y]=$val
}



#piece
declare -i piece_x
declare -i piece_y

declare -a relpiece_x
declare -a relpiece_y

relpiece_x=0
relpiece_y=0

abs_x() {
  echo $((piece_x+relpiece_x[$1]))
}

abs_y() {
  echo $((piece_y+relpiece_y[$1]))
}


spawn() {
  piece_x=$((width/2))
  piece_y=0
  relpiece_x[1]=1 #TODO replace with random piece choice
  relpiece_y[1]=0
  relpiece_x[2]=-1
  relpiece_y[2]=0
  forpiece setfield falling
}

forpiece() {
  local cmd=$1
  shift
  for ((block=0; block < $dim; block++)); do
    $cmd $(abs_x $block) $(abs_y $block) $@
  done
}

fall() {
  if connects piece; then
    land
  else
    move 0 1
  fi
}

slide() {
  local x=$1
  local newx=$((piece_x + x ))
  for ((tile=0; tile < $dim; tile++)); do
    rx=$((newx+relpiece_x[$tile]))
    [[ $rx -ge 0  && $rx -lt $width ]] || return
  done
  move $x 0
}

turn() {
  local tmp
  forpiece setfield empty
  for ((tile=0; tile < $dim; tile++)); do
    tmp=${relpiece_x[$tile]}
    relpiece_x[$tile]=$((-relpiece_y[$tile]))
    relpiece_y[$tile]=$tmp
  done
  forpiece setfield falling
}

move() {
    local x=$1
    local y=$2
    forpiece setfield empty
    ((piece_x+=$x))
    ((piece_y+=$y))
    forpiece setfield falling
  }

land() { #executed when piece lands
  forpiece setfield base
  score
  spawn
}

score() {
  local lnum=0
  local -a piecelines=()
  [[ piece_y -eq 0 ]] && gameover;
  for ((tile=0; tile < $dim; tile++)); do
    piecelines[$(abs_y $tile)]=true
  done
  for line in ${!piecelines[@]}; do
    ${piecelines[$line]} && linecomplete $line && ((++lnum)) && ((score+=$lnum))
  done
}

gameover() {
  end
}

linecomplete() {
  local y=$1
  for (( x=0; x<$width; x++));do
    [[ $(getfield $x $y) == base ]] || return 1
  done
  downshift $y
}

downshift() {
  local level=$1
  for ((y=$level;y>0;y--)); do
    for (( x=0; x<$width; x++));do
      setfield $x $y $(getfield $x $((y-1)) )
    done
  done
}

connects() { #todo: adjust for 4-block
  for ((tile=0; tile < $dim; tile++)); do 
    [[ $(abs_y $tile) -ge $((height - 1 )) ]] && return 0
    [[ $(getfield $(abs_x $tile) $(($(abs_y $tile)+1)) ) == 'base' ]] && return 0
  done
  return 1
}

build_map() {
 for (( y=0; y < $height; y++ )); do
    for (( x=0; x < $width; x++ )); do
      map[$x+1 + ($y+1) * $xsize]=${rep[$(getfield $x $y)]}
    done
  done
  for ((i=0; i<${#score}; i++ )); do
    map[$i+1 *$xsize*($ysize-1)]=${score:$i:1}
  done
}

game_setup() {
  for (( y=0; y < $height; y++ )); do
    for (( x=0; x < $width; x++ )); do
      setfield $x $y empty
    done 
  done
  for ((x=0; x < $xsize; x++)); do
    map[$x]=${rep[border]}
    map[$x + $xsize * ($ysize -2)]=${rep[border]}
  done
  for ((y=0; y < $((ysize-1)); y++)); do
    map[$y*$xsize]=${rep[border]}
    map[$xsize - 1 + $xsize*$y]=${rep[border]}
  done
  spawn
}

worldtick() {
  fall
  build_map
}

action() {
  local playerinput=$1
  case $playerinput in
    q) close ;;
    a) slide -1 ;;
    d) slide 1 ;;
    s) fall ;;
    w) turn ;;
  esac
}

engine
